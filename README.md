# N-bit Configurable Carry Look-Ahead Adder (CLA)

In digital systems, arithmetic operations are the foundation of microprocessors. Since any operation can be reduced to binary addition, designing efficient adders is crucial.
This repository contains the VHDL code for a scalable N-bit carry look-ahead adder.

> [!IMPORTANT]
> The code has been structured for readability and ease of maintenance.
> The repository also provides a testbench for functional validation of the proposed architecture.

## Operating Principle

The Carry Look-Ahead (CLA) adder aims to minimize the delay associated with calculating the carry bits and, consequently, the sum bits.
Unlike a Ripple Carry Adder (RCA), in which the carry must propagate sequentially from one stage to the next—requiring the i-th Full-Adder (FA) to wait for the carry generated by the previous stage before producing a valid result—the CLA overcomes this limitation by introducing <em>**propagate**</em> (p<sub>i</sub>) and <em>**generate**</em> (g<sub>i</sub>) signals calculated in parallel from the operand bits input to each FA.  
From the FA's truth table, these signals are defined as:

p<sub>i</sub> = A<sub>i</sub> <em>xor</em> B<sub>i</sub>  
g<sub>i</sub> = A<sub>i</sub> <em>and</em> B<sub>i</sub>

It follows that the carry bits and sum bits can be determined by exploiting the relationships linking them to the p<sub>i</sub> and g<sub>i</sub> signals, as:

Sum<sub>i</sub> = A<sub>i</sub> <em>xor</em> B<sub>i</sub> <em>xor</em> C<sub>i</sub> = p<sub>i</sub> <em>xor</em> C<sub>i</sub>  
C<sub>i+1</sub> = (A<sub>i</sub> <em>and</em> B<sub>i</sub>) + (A<sub>i</sub> <em>xor</em> B<sub>i</sub>) <em>and</em> C<sub>i</sub> = g<sub>i</sub> + p<sub>i</sub> <em>and</em> C<sub>i</sub>

Using the C<sub>i+1</sub> relationship recursively, we obtain:

C<sub>1</sub> = g<sub>0</sub> + p<sub>0</sub> · C<sub>0</sub>  
C<sub>2</sub> = g<sub>1</sub> + p<sub>1</sub> · C<sub>1</sub> = g<sub>1</sub> + p<sub>1</sub> · g<sub>0</sub> + p<sub>1</sub> · p<sub>0</sub> · C<sub>0</sub>  
C<sub>3</sub> = g<sub>2</sub> + p<sub>2</sub> · C<sub>2</sub> = g<sub>2</sub> + p<sub>2</sub> · g<sub>1</sub> + p<sub>2</sub> · p<sub>1</sub> · g<sub>0</sub> + p<sub>2</sub> · p<sub>1</sub> · p<sub>0</sub> · C<sub>0</sub>  
C<sub>4</sub> = g<sub>3</sub> + p<sub>3</sub> · C<sub>3</sub> = g<sub>3</sub> + p<sub>3</sub> · g<sub>2</sub> + p<sub>3</sub> · p<sub>2</sub> · g<sub>1</sub> + p<sub>3</sub> · p<sub>2</sub> · p<sub>1</sub> · g<sub>0</sub> + p<sub>3</sub> · p<sub>2</sub> · p<sub>1</sub> · p<sub>0</sub> · C<sub>0</sub>  
.  
.  
.  
C<sub>i+1</sub> = g<sub>i</sub> + p<sub>i</sub> · C<sub>i</sub> = g<sub>i</sub> + p<sub>i</sub> · g<sub>i-1</sub> + p<sub>i-1</sub> · g<sub>i-2</sub> · p<sub>i</sub> · ... · p<sub>2</sub> · p<sub>1</sub> · g<sub>0</sub> + p<sub>i</sub> · ... · p<sub>1</sub> · p<sub>0</sub> · C<sub>0</sub>  

It is clear that the carry bits depend exclusively on the CLA input carry (C<sub>in</sub> = C<sub>0</sub>), as well as the p<sub>i</sub> and g<sub>i</sub> signals.
Consequently, all carry bits, as well as the sum bits, will be calculated simultaneously, optimizing the sum calculation between two operands. However, the improvement in speed leads to an increase in circuit complexity.  
In particular, calculating the carry to the i-th stage requires the use of AND and OR logic gates with a number of inputs equal to <em>n</em> + 1. This design choice leads to an increase in the occupied area and introduces greater constraints related to **fan-in** of the logic gates that must be appropriately considered during the design phase.  
.  
.  
.  
WORK IN PROGRES.........  
.  
.  
.  

## Theorical Architectural Overview

*

## Key Features

* **N-bit Addition:** Perform addition on two N-bit `std_logic_vector` inputs.
* **High-Speed Architecture:** Implements the CLA algorithm based on <em>**group propagate**</em> (gp<sub>i</sub>) and <em>**group generate**</em> (gg<sub>i</sub>) signals to minimize the propagation delay associated with carry signals and minimize fan-in issues, offering a significant performance advantage over a standard RCA.
* **Scalable Design:** The architecture is configurable, as the implementation has been structured to allow the CLA size to be parameterized during instantiation, depending on the application needs.
* **2's Complement Representation:** Sign extension has been implemented to ensure the correct representation of negative values. For positive operands, an adequate word length must be used to prevent overflow.


## Architectural Overview

The adder is constructed using three primary components in a hierarchical structure:  

1. **`CLA.vhd`**: The top-level entity that instantiates and connects `CarryGen` and `FA_CLA` components to form the N-bit adder.
2. **`CarryGen.vhd`**: A N-bit block that contains the core CLA logic. It generates <em>pp<sub>i</sub></em> and <em>gp<sub>i</sub></em> signals for fast calculation of carry bits (in parallel).
3. **`FA_CLA.vhd`**: A slightly modified 1-bit full-adder (without output carry), which serves as the fundamental building block for for calculating the p<sub>i</sub> and g<sub>i</sub> signals, and the sum.