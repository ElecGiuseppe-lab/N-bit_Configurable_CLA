# N-bit Configurable Carry Look-Ahead Adder (CLA)

In digital systems, arithmetic operations are the foundation of microprocessors. Since any operation can be reduced to binary addition, designing efficient adders is crucial.
This repository contains the VHDL code for a scalable N-bit carry look-ahead adder.

> [!IMPORTANT]
> The code has been structured for readability and ease of maintenance.
> The repository also provides a testbench for functional validation of the proposed architecture.

## Operating Principle

The Carry Look-Ahead (CLA) adder aims to minimize the delay associated with calculating the carry bits and, consequently, the sum bits.
Unlike a Ripple Carry Adder (RCA), in which the carry must propagate sequentially from one stage to the next—requiring the i-th Full-Adder (FA) to wait for the carry generated by the previous stage before producing a valid result—the CLA overcomes this limitation by introducing <em>**propagate**</em> (p<sub>i</sub>) and <em>**generate**</em> (g<sub>i</sub>) signals calculated in parallel from the operand bits input to each FA.  
From the FA's truth table, these signals are defined as:

p<sub>i</sub> = A<sub>i</sub> <em>xor</em> B<sub>i</sub>  
g<sub>i</sub> = A<sub>i</sub> <em>and</em> B<sub>i</sub>

It follows that the carry bits and sum bits can be determined by exploiting the relationships linking them to the p<sub>i</sub> and p<sub>i</sub> signals, as:

Sum<sub>i</sub> = A<sub>i</sub> <em>xor</em> B<sub>i</sub> <em>xor</em> Carry<sub>i</sub> = p<sub>i</sub> <em>xor</em> Carry<sub>i</sub>  
Carry<sub>i+1</sub> = (A<sub>i</sub> <em>and</em> B<sub>i</sub>) <em>or</em> (A<sub>i</sub> <em>xor</em> B<sub>i</sub>) <em>and</em> Carry<sub>i</sub> = g<sub>i</sub> <em>or</em> p<sub>i</sub> <em>and</em> Carry<sub>i</sub>

Using the Carry<sub>i+1</sub> relationship recursively, we obtain:

Carry<sub>1</sub> = g<sub>0</sub> <em>or</em> p<sub>0</sub> <em>and</em> C<sub>0</sub>
Carry<sub>2</sub> = g<sub>1</sub> <em>or</em> p<sub>1</sub> <em>and</em> C<sub>1</sub> = g<sub>1</sub> <em>or</em> p<sub>1</sub> <em>and</em> g<sub>0</sub> <em>or</em> p<sub>1</sub> <em>and</em> p<sub>0</sub> <em>and</em> C<sub>0</sub>
Carry<sub>3</sub> = g<sub>2</sub> <em>or</em> p<sub>2</sub> <em>and</em> C<sub>2</sub> = g<sub>2</sub> <em>or</em> p<sub>2</sub> <em>and</em> g<sub>1</sub> <em>or</em> p<sub>2</sub> <em>and</em> p<sub>1</sub> <em>and</em> g<sub>0</sub> <em>or</em> p<sub>2</sub> <em>and</em> p<sub>1</sub> <em>and</em> p<sub>0</sub> <em>and</em> C<sub>0</sub>
Carry<sub>4</sub> = g<sub>3</sub> <em>or</em> p<sub>3</sub> <em>and</em> C<sub>3</sub> = g<sub>3</sub> <em>or</em> p<sub>3</sub> <em>and</em> g<sub>2</sub> <em>or</em> p<sub>3</sub> <em>and</em> p<sub>2</sub> <em>and</em> g<sub>1</sub> <em>or</em> p<sub>3</sub> <em>and</em> p<sub>2</sub> <em>and</em> p<sub>1</sub> <em>and</em> g<sub>0</sub> <em>or</em> p<sub>3</sub> <em>and</em> p<sub>2</sub> <em>and</em> p<sub>1</sub> <em>and</em> p<sub>0</sub> <em>and</em> C<sub>0</sub>
.
.
.
Carry<sub>i+1</sub> = g<sub>i</sub> <em>or</em> p<sub>i</sub> <em>and</em> C<sub>i</sub> = g<sub>i</sub> <em>or</em> p<sub>i</sub> <em>and</em> g<sub>i-1</sub> <em>or</em> p<sub>i-1</sub> <em>and</em> g<sub>i-2</sub> <em>and</em> p<sub>i</sub> <em>and</em> ... p<sub>2</sub> <em>and</em> p<sub>1</sub> <em>and</em> g<sub>0</sub> <em>or</em> p<sub>i</sub> <em>and</em> ... p<sub>1</sub> <em>and</em> p<sub>0</sub> <em>and</em> C<sub>0</sub>

It is clear that the carry bits depend exclusively on the CLA input carry (C<sub>in</sub> = C<sub>0</sub>), as well as the pi and gi signals.
Consequently, all carry bits, as well as the sum bits, will be calculated simultaneously, optimizing the sum calculation between two operands.

## Key Features

* 