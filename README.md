# Configurable N-bit Signed Carry Look-Ahead (CLA) Adder

## Abstract

In digital systems, arithmetic operations are the foundation of microprocessors. Since any operation can be reduced to binary addition, designing efficient adders is crucial.
This repository contains the VHDL code for a scalable N-bit signed carry look-ahead adder.

> [!NOTE]
> The code has been structured for readability and ease of maintenance.
> The repository also provides a testbench for functional validation of the proposed architecture.

## Operating Principle

The Carry Look-Ahead (CLA) adder aims to minimize the delay associated with calculating the carry bits and, consequently, the sum bits.
Unlike a Ripple Carry Adder (RCA), in which the carry must propagate sequentially from one stage to the next—requiring the i-th Full-Adder (FA) to wait for the carry generated by the previous stage before producing a valid result—the CLA adder overcomes this limitation by introducing <em>**propagate**</em> (<em>p<sub>i</sub></em>) and <em>**generate**</em> (<em>g<sub>i</sub></em>) signals calculated in parallel from the operand bits input to each FA.  
From the FA's truth table, these signals are defined as:

p<sub>i</sub> = A<sub>i</sub> <em>xor</em> B<sub>i</sub>  
g<sub>i</sub> = A<sub>i</sub> <em>and</em> B<sub>i</sub>

It follows that the carry bits and sum bits can be determined by exploiting the relationships linking them to the <em>p<sub>i</sub></em> and <em>g<sub>i</sub></em> signals, as:

Sum<sub>i</sub> = A<sub>i</sub> <em>xor</em> B<sub>i</sub> <em>xor</em> C<sub>i</sub> = p<sub>i</sub> <em>xor</em> C<sub>i</sub>  
C<sub>i+1</sub> = (A<sub>i</sub> <em>and</em> B<sub>i</sub>) <em>or</em> (A<sub>i</sub> <em>xor</em> B<sub>i</sub>) <em>and</em> C<sub>i</sub> = g<sub>i</sub> <em>or</em> (p<sub>i</sub> <em>and</em> C<sub>i</sub>)

Using the C<sub>i+1</sub> relationship recursively, we obtain:

C<sub>1</sub> = g<sub>0</sub> + p<sub>0</sub>C<sub>0</sub>  
C<sub>2</sub> = g<sub>1</sub> + p<sub>1</sub>C<sub>1</sub> = g<sub>1</sub> + p<sub>1</sub>g<sub>0</sub> + p<sub>1</sub>p<sub>0</sub>C<sub>0</sub>  
C<sub>3</sub> = g<sub>2</sub> + p<sub>2</sub>C<sub>2</sub> = g<sub>2</sub> + p<sub>2</sub>g<sub>1</sub> + p<sub>2</sub>p<sub>1</sub>g<sub>0</sub> + p<sub>2</sub>p<sub>1</sub>p<sub>0</sub>C<sub>0</sub>  
C<sub>4</sub> = g<sub>3</sub> + p<sub>3</sub>C<sub>3</sub> = g<sub>3</sub> + p<sub>3</sub>g<sub>2</sub> + p<sub>3</sub>p<sub>2</sub>g<sub>1</sub> + p<sub>3</sub>p<sub>2</sub>p<sub>1</sub>g<sub>0</sub> + p<sub>3</sub>p<sub>2</sub>p<sub>1</sub>p<sub>0</sub>C<sub>0</sub>  
.  
.  
.  
C<sub>i+1</sub> = g<sub>i</sub> + p<sub>i</sub>C<sub>i</sub> = g<sub>i</sub> + p<sub>i</sub>g<sub>i-1</sub> + p<sub>i-1</sub>g<sub>i-2</sub> + ... + p<sub>i</sub>...p<sub>2</sub>p<sub>1</sub>g<sub>0</sub> + p<sub>i</sub>...p<sub>1</sub>p<sub>0</sub>C<sub>0</sub>  

It is clear that the carry bits depend exclusively on the CLA input carry (C<sub>in</sub> = C<sub>0</sub>), as well as the p<sub>i</sub> and g<sub>i</sub> signals.
Consequently, all carry bits, as well as the sum bits, will be calculated simultaneously, optimizing the sum calculation between two operands. However, the improvement in speed leads to an increase in circuit complexity.  
In particular, calculating the carry to the i-th stage requires the use of AND and OR logic gates with a number of inputs equal to <em>n</em> + 1. This design choice leads to an increase in the occupied area and introduces greater constraints related to **fan-in** of the logic gates that must be appropriately considered during the design phase.  


## Theorical Architectural Overview

The CLA adder is composed of two fundamental blocks:

1. **FA block:** Dedicated to the generation of the sum and the <em>p<sub>i</sub></em> and <em>g<sub>i</sub></em> signals.
2. **CLA block:** Dedicated to fast calculation of carry overs using <em>**propagate**</em> (<em>p<sub>i</sub></em>) and <em>**generate**</em> (<em>g<sub>i</sub></em>) signals.

![alt text](https://github.com/ElecGiuseppe-lab/N-bit_Configurable_CLA/blob/master/img/block_diagram.png)


## Key Features

* **N-bit Addition:** Perform addition on two N-bit `std_logic_vector` inputs.
* **High-Speed Architecture:** Implements the CLA algorithm based on <em>p<sub>i</sub></em> and <em>g<sub>i</sub></em> signals to minimize the propagation delay associated with carry signal, offering a significant performance advantage over a standard RCA.
* **Scalable Design:** The architecture is configurable, as the implementation has been structured to allow the CLA adder size to be parameterized during instantiation, depending on the application needs.
* **Representation Signed Binary Numbers in 2's Complement Notation:** Sign extension has been implemented to ensure the correct representation of negative integer values. For positive operands, an adequate word length must be used to prevent overflow (e.g. 255 -> 8-bit to extend 9-bit).


## Practical Architectural Overview

The adder is constructed using three primary components in a hierarchical structure:  

1. **`CLA_adder.vhd`**: The top-level entity that instantiates and connects `CarryGen` and `FA_CLA` components to form the N-bit adder.
2. **`CarryGen.vhd`**: A N-bit block that contains the core CLA logic. It generates <em>p<sub>i</sub></em> and <em>g<sub>i</sub></em> signals for fast calculation of carry bits (in parallel).
3. **`FA_CLA.vhd`**: A slightly modified 1-bit FA (without output carry), which serves as the fundamental building block for calculating the p<sub>i</sub> and g<sub>i</sub> signals, and the sum.


## Verification

The design was verified using the `CLA_tb.vhd` testbench. This testbench is self-checking and uses assert statements to automatically report errors.


## Behavioral Simulation

![alt text](https://github.com/ElecGiuseppe-lab/N-bit_Configurable_CLA/blob/master/img/CLA_tb.png)


## Possible Improvements

* **Synthesis and Implementation:** The next logical step for this project is to synthesize the design for a target FPGA device. This process would provide key metrics on hardware resource utilization (LUTs, FFs), power dissipation and timing performance (maximum operating frequency).
> [!IMPORTANT]
> Requires the use of a clock signal.
* **Pipelining:** To further increase throughput for applications that process continuous data, the adder could be pipelined. This would involve adding registers between the CLA adder block stages.


## Getting Started For Test

### Prerequisites
- Xilinx Vivado Design Suite
- Knowledge of VHDL
- Basic understanding of signals and systems

### Steps to Run the Project
1. Clone the repository:
   ```bash
   git clone https://github.com/ElecGiuseppe-lab/N-bit_Configurable_CLA.git
   ```
2. Open Vivado and create a new project.
3. Add the provided VHDL source files (the VHDL source files are located in the `CLA_Adder/src` directory).
5. Run behavioral simulation (the corresponding testbench are in the `CLA_Adder/sim` directory).
